package net.sf.jclec.problem.classification.evolutionarylearner;

import com.yahoo.labs.samoa.instances.InstancesHeader;

import net.sf.jclec.problem.classification.blocks.AttributeValue;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.syntaxtree.IMutateSyntaxTree;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.SyntaxTreeSchema;
import net.sf.jclec.syntaxtree.TerminalNode;
import net.sf.jclec.util.random.IRandGen;

public class RuleMutator implements IMutateSyntaxTree
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -2706522794304044852L;

	private InstancesHeader context;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */

	public RuleMutator(InstancesHeader context) 
	{
		super();

		this.context = context;
	}

	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////

	@Override
	public SyntaxTree mutateSyntaxTree(SyntaxTree parent, SyntaxTreeSchema schema, IRandGen randgen) {

		// Select randomly a symbol in parent
		int p_branchStart = randgen.choose(0, parent.size());

		SyntaxTree son = new SyntaxTree();

		if (parent.getNode(p_branchStart) instanceof NonTerminalNode) 
		{
			NonTerminalNode selectedSymbol = (NonTerminalNode) parent.getNode(p_branchStart);

			int p_branchEnd = endOfBranch(parent, p_branchStart);

			for (int i = 0; i < p_branchStart; i++)
				son.addNode(parent.getNode(i).copy());

			// Set branch depth (to check maximum size)
			int p_branchDepth = parent.derivSize();
			int p_swapBranch = 0;
			for (int i = p_branchStart; i <= p_branchEnd; i++) 
				if (parent.getNode(i).arity() != 0)
					p_swapBranch++;

			int beforeValue = schema.getMaxDerivSize() - p_branchDepth + p_swapBranch;

			if (p_swapBranch < schema.getMinDerivSize())
				p_swapBranch = schema.getMinDerivSize();

			int nOfDer = randgen.choose(p_swapBranch, beforeValue);

			schema.fillSyntaxBranch(son, selectedSymbol.getSymbol(), nOfDer, randgen);

			for (int i = p_branchEnd + 1; i < parent.size(); i++)
				son.addNode(parent.getNode(i).copy());
		} 
		else
		{
			TerminalNode selectedSymbol = (TerminalNode) parent.getNode(p_branchStart);
			TerminalNode node = selectOtherTerminalNode(selectedSymbol,schema,randgen);

			if(node == null)
				p_branchStart--;

			for (int i = 0; i < p_branchStart; i++) 
				son.addNode(parent.getNode(i).copy());	

			if(node != null)
				son.addNode(node);
			else
				p_branchStart++;

			if(node != null && node.getCode() instanceof AttributeValue)
			{
				// If new attribute was mutated, then need to generate new value as well in the domain of the new attribute
				for(TerminalNode n : schema.getTerminals())
				{
					if(n.getSymbol().equals("values"+node.getSymbol()))
					{
						if (n.getCode() instanceof RandomConstantOfContinuousValues)
						{
							TerminalNode terminalAux = new TerminalNode(n.getSymbol(), new RandomConstantOfContinuousValues(randgen));
							net.sf.jclec.util.range.Interval interval = ((RandomConstantOfContinuousValues) n.getCode()).getInterval();
							((RandomConstantOfContinuousValues) terminalAux.getCode()).setInterval(interval);
							((RandomConstantOfContinuousValues) terminalAux.getCode()).initializeValue();
							son.addNode(terminalAux);
						}

						if (n.getCode() instanceof RandomConstantOfDiscreteValues)
						{
							TerminalNode terminalAux = new TerminalNode(n.getSymbol(), new RandomConstantOfDiscreteValues(randgen));
							net.sf.jclec.util.intset.Interval interval = ((RandomConstantOfDiscreteValues) n.getCode()).getInterval();
							((RandomConstantOfDiscreteValues) terminalAux.getCode()).setInterval(interval);
							((RandomConstantOfDiscreteValues) terminalAux.getCode()).initializeValue();
							son.addNode(terminalAux);
						}

						for (int i = p_branchStart + 2; i < parent.size(); i++)
							son.addNode(parent.getNode(i).copy());

						return son;
					}
				}
			}
			else
				for (int i = p_branchStart + 1; i < parent.size(); i++)
					son.addNode(parent.getNode(i).copy());
		}

		return son;
	}

	/**
	 * Gets the index of the final symbol of a production
	 * 
	 * @param tree the syntaxtree
	 * @param currentNode the node from which the production is done
	 * 
	 * @return the index of the final symbol of the production
	 */
	private final int endOfBranch(SyntaxTree tree, int currentNode) 
	{
		int count = 1;

		while (count != 0) 
		{
			count += tree.getNode(currentNode).arity() - 1;
			currentNode = currentNode + 1;
		}

		return currentNode - 1;
	}

	/////////////////////////////////////////////////////////////////
	// ---------------------------------------------- Private methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Selects a compatible node to mutate
	 * 
	 * @param symbol current symbol
	 * @param schema SyntaxTreeSchema
	 * @param randgen random generator
	 * 
	 * @return a compatible node
	 */
	protected TerminalNode selectOtherTerminalNode(TerminalNode symbol, SyntaxTreeSchema schema, IRandGen randgen) 
	{
		if (symbol.getSymbol().equalsIgnoreCase("="))
			return schema.getTerminal("!=");

		if (symbol.getSymbol().equalsIgnoreCase("!="))
			return schema.getTerminal("=");

		if (symbol.getSymbol().equalsIgnoreCase("<")) 
			return schema.getTerminal(">");

		if (symbol.getSymbol().equalsIgnoreCase(">")) 
			return schema.getTerminal("<");

		if (symbol.getSymbol().equalsIgnoreCase("AND"))
			return schema.getTerminal("OR");

		if (symbol.getSymbol().equalsIgnoreCase("OR"))
			return schema.getTerminal("AND");

		if (symbol.getSymbol().equalsIgnoreCase("NOT"))
			return null;

		if (symbol.getCode() instanceof RandomConstantOfContinuousValues) 
		{
			TerminalNode terminalAux = new TerminalNode(symbol.getSymbol(), new RandomConstantOfContinuousValues(randgen));
			net.sf.jclec.util.range.Interval interval = ((RandomConstantOfContinuousValues) symbol.getCode()).getInterval();
			((RandomConstantOfContinuousValues) terminalAux.getCode()).setInterval(interval);
			((RandomConstantOfContinuousValues) terminalAux.getCode()).initializeValue();
			return terminalAux;
		}

		if (symbol.getCode() instanceof RandomConstantOfDiscreteValues) 
		{
			TerminalNode terminalAux = new TerminalNode(symbol.getSymbol(), new RandomConstantOfDiscreteValues(randgen));
			net.sf.jclec.util.intset.Interval interval = ((RandomConstantOfDiscreteValues) symbol.getCode()).getInterval();
			((RandomConstantOfDiscreteValues) terminalAux.getCode()).setInterval(interval);
			((RandomConstantOfDiscreteValues) terminalAux.getCode()).initializeValue();
			return terminalAux;
		}

		if (symbol.getCode() instanceof AttributeValue) 
		{
			int newAttribute = randgen.choose(0, context.numAttributes()-1);
			String newAttributeName = context.attribute(newAttribute).name();
			
			for(TerminalNode node : schema.getTerminals())
				if(node.getSymbol().equals(newAttributeName))
					return node;
		}

		System.err.println("Mutator: this should not happen " + symbol);
		return symbol;
	}
}